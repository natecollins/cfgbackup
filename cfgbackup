#!/bin/bash
################################################################################
# Copyright (c) 2017 Nathan Collins
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.
################################################################################

VERSION=0.4.2

#######################################
# MISC HELPER FUNCTIONS
#######################################

###############################
## Perform check for required commands and settings
## Will end script with exit code 1 if a requirement is not met
precheck_requirements() {
    # Do not allow config files that are writable by other
    CONF_PERMS=$( stat -c %a $CONFIG_FILE)
    OWRITE=$(( ${CONF_PERMS: -1} & 2 ))
    if [[ $OWRITE -ne 0 ]]; then
        echo "ERROR: cfgbackup does not allow world writable config files."
        exit 1
    fi

    # Verify required tools exist and have required versions
    if ! bash_gte_420; then
        echo "ERROR: cfgbackup requires Bash version 4.2.0 or greater."
        exit 1
    fi
    # Verify rsync is available
    if ! rsync_exists; then
        echo "ERROR: cfgbackup requires rsync is available."
        exit 1
    fi
    # Check for sort with version ability (gnu coreutils)
    if ! coreutils_sort; then
        echo "ERROR: cfgbackup requires 'sort -V' support (GNU Coreutils)."
        exit 1
    fi
}

###############################
## Check if array contains a given value
##  $1 -> Name of array to search
##  $2 -> Value to find
## Returns 0 if an element matches the value to find
array_contains() {
    local ARRNAME=$1[@]
    local HAYSTACK=( ${!ARRNAME} )
    local NEEDLE="$2"
    for VAL in "${HAYSTACK[@]}"; do
        if [[ $NEEDLE == $VAL ]]; then
            return 0
        fi
    done
    return 1
}

###############################
## Get the index of matched value from an indexed array
##  $1 -> Name of array to search
##  $2 -> Value to find
## Prints the index of matching value; prints -1 if value not found
array_value_index() {
    local ARRNAME=$1[@]
    local HAYSTACK=( ${!ARRNAME} )
    local NEEDLE="$2"
    for KEY in "${!HAYSTACK[@]}"; do
        if [[ $NEEDLE == ${HAYSTACK[$KEY]} ]]; then
            echo $KEY
            return
        fi
    done
    echo -1
}

###############################
## Get the index of a matching substring within a string
##  $1 -> String to search
##  $2 -> Substring to match
## Prints the index of matching substring; prints -1 if not found
substr_index() {
    local HAYSTACK="$1"
    local NEEDLE="$2"
    local PREMATCH="${HAYSTACK%%$NEEDLE*}"
    if [[ $PREMATCH != $HAYSTACK ]]; then
        echo ${#PREMATCH}
        return
    fi
    echo -1
}

###############################
## Combine two strings into a full file/directory path
##  $1 -> First part of path, may not be empty
##  $2 -> Second part of path
## Returns the combined path, with no trailing slash
path_join() {
    if [[ $1 == "" ]]; then
        echo "ERROR: Cannot path_join empty string."
        exit 1
    fi
    PATH1="${1%/}"
    PATH2="${2%/}"
    PATH2="${PATH2#/}"
    if [[ $PATH2 != "" ]]; then
        PATH2="/${PATH2}"
    fi
    echo "${PATH1}${PATH2}"
}

###############################
## Combine two strings into a full file/directory path, and
## escapes the resulting string for use in a command
##  $1 -> First part of path, may not be empty
##  $2 -> Second part of path
## Returns the combined path, with no trailing slash, escaped
epath_join() {
    P=$( path_join "$1" "$2" )
    printf '%q' "$P"
}

###############################
## Check if rsync is found
## Returns 0 if found and executable
rsync_exists() {
    DUMMY=$( ${CONFIG[RSYNC_PATH]} --version 2>&1 )
    return $?
}

###############################
## Check if hardlink is found
## Returns 0 if found and executable
hardlink_exists() {
    DUMMY=$( ${CONFIG[HARDLINK_PATH]} -h 2>&1 )
    return $?
}

###############################
## Get what version of rsync are we using
## Outputs the rsync verion number, e.g. 3.1.0
version_rsync() {
    ${CONFIG[RSYNC_PATH]} --version | head -n 1 | awk '{ print $3 }'
}

###############################
## Is the rsync version at least 3.1.0
## Returns 0 if version 3.1.0 or greater
rsync_gte_310() {
    RSYNC_VER=$( version_rsync )
    RSYNC_CHECK=$( echo -e "${RSYNC_VER}\n3.1.0" | ${CONFIG[SORT_PATH]} -V | head -n 1 )
    if [[ $RSYNC_CHECK == "3.1.0" ]]; then
        return 0;
    fi
    return 1
}

###############################
## Is the running version of bash at least 4.2.0
## Returns 0 if version 4.2.0 or greater
bash_gte_420() {
    BASH_VCHECK=$( echo -e "${BASH_VERSION}\n4.2.0" | ${CONFIG[SORT_PATH]} -V | head -n 1 )
    if [[ $BASH_VCHECK == "4.2.0" ]]; then
        return 0;
    fi
    return 1
}

###############################
## Check for sort from coreutils with version sort
## Return 0 if sort -V works
coreutils_sort() {
    DUMMY=$( echo | ${CONFIG[SORT_PATH]} -V )
    if [[ $? -eq 0 ]]; then
        return 0
    fi
    return 1
}

###############################
## Pause script execution and prompt for key to continue
debug_pause() {
    read -n1 -s -r -p "Press a key to continue..."
    echo
}

#######################################
# EMAIL FUNCTIONS
#######################################

###############################
## Check if mail command exists
mail_exists() {
    command -v ${CONFIG[MAIL_PATH]} > /dev/null
    return $?
}

###############################
## Attempt to send an email
##  $1 -> Recipient address
##  $2 -> Subject
##  $3 -> Message
mailer() {
    if ! mail_exists; then
        log_entry "| Unable to send email to ${RECIPIENT}; could not find program: ${COMMAND[MAIL_PATH]}"
        return 1
    fi
    RECIPIENT=$1
    SUBJECT=$2
    MESSAGE=$3
    echo "$MESSAGE" | ${CONFIG[MAIL_PATH]} -s "$SUBJECT" "$RECIPIENT"

    if [[ $? != 0 ]]; then
        # Log mail failure
        log_entry "| FAILED to send email to ${RECIPIENT}. Subject: \"$SUBJECT\""
        echo "FAILED to send email to ${RECIPIENT}. Subject: \"$SUBJECT\""
        return 1
    fi
    return 0
}

###############################
## Attempt to send an failure notifcation about rsync exit code
##  $1 -> The rsync exit code
mailer_rsync_exit() {
    if [[ ${CONFIG[NOTIFY_EMAIL]} != "" ]]; then
        mailer "${CONFIG[NOTIFY_EMAIL]}" "cfgbackup job '${CONF_NAME}' failed with exit code $RSYNC_EXIT" "
The rsync command used in the '${CONF_NAME}' backup job exited with code ${RSYNC_EXIT}.

For more details, view the log file:
  $LOG_FILE
"
    fi
}

#######################################
# LOGGING FUNCTIONS
#######################################

###############################
## Check if log directory is writable
## Return 0 if writable
log_can_write() {
    [[ -d ${LOG_DIR} && -w ${LOG_DIR} ]]
    return $?
}

###############################
## Attempt to compress old logs
log_compress() {
    if [[ ${CONFIG[COMPRESS_LOGS]} == "1" ]]; then
        # List files that can match LOG_FILENAME minus exact DATE and TIME variables
        LOG_MATCH=${CONFIG[LOG_FILENAME]//DATE/*}
        LOG_MATCH=${LOG_MATCH//TIME/*}
        LM_PATH=$( epath_join ${CONFIG[LOG_DIR]} )
        # Zip old log files
        ZOUT=$( find $LM_PATH -mindepth 1 -maxdepth 1 -mtime +2 -name "${LOG_MATCH}" -exec ${CONFIG[COMPRESS_PATH]} {} \; 2>&1 )
        ZEXIT=$?
        if [[ $ZEXIT -ne 0 ]]; then
            echo "ERROR: cfgbackup was unable to compress old logs; returned exit code $ZEXIT"
            echo "Output was: $ZOUT"
            exit 1
        fi
    fi
}

###############################
## Initialize log
## Return 0 on success
log_init() {
    CONFIG[LOG_FILENAME]=${CONFIG[LOG_FILENAME]//CONFNAME/$CONF_NAME}
    declare -g LOG_FILE
    declare -g LOG_DIR
    LOG_FILE=${CONFIG[LOG_FILENAME]//DATE/$(date +%Y%m%d)}
    LOG_FILE=${LOG_FILE//TIME/$(date +%H%M%S)}
    LOG_DIR=$( epath_join ${CONFIG[LOG_DIR]} )
    # Join path and escape
    LOG_FILE=$( epath_join ${CONFIG[LOG_DIR]} ${LOG_FILE} )
    # Attempt to create the log directory if it doesn't exist
    mkdir -p $LOG_DIR > /dev/null 2>&1
    return $( log_can_write )
}

###############################
## Create a logfile entry
##  $1 -> Log message entry
log_entry() {
    echo "$1" >> $LOG_FILE
}

###############################
## Get name of most recent log file for current config
## Prints escaped full path of file, or empty string if no match
log_last_file() {
    # List files that can match LOG_FILENAME minus exact DATE and TIME variables
    LOG_MATCH=${CONFIG[LOG_FILENAME]//DATE/*}
    LOG_MATCH=${LOG_MATCH//TIME/*}
    LM_PATH=$( epath_join ${CONFIG[LOG_DIR]} )
    LM_PATH=$( path_join $LM_PATH $LOG_MATCH )
    # Get list of files
    LASTLOG=( $( ls -1 $LM_PATH 2> /dev/null | tail -n 1 ) )
    # Return last entry
    echo $LASTLOG
}

#######################################
# PARSE CONFIG FILE
#######################################

###############################
## Creates an array of config variables with default values
default_config() {
    declare -g -A CONFIG
    CONFIG[NOTIFY_EMAIL]=
    CONFIG[LOG_DIR]=/var/log/cfgbackup/
    CONFIG[LOG_FILENAME]=CONFNAME_DATE.log
    CONFIG[SOURCE_DIR]=
    CONFIG[TARGET_DIR]=
    CONFIG[RSYNC_FLAGS]=
    CONFIG[NOTIFY_RSYNC_FLAGS]=-O
    CONFIG[BACKUP_TYPE]=
    CONFIG[ROTATE_SUBDIR]=backup-NUM1
    CONFIG[RUNNING_DIRNAME]=backup-running
    CONFIG[MIRROR_CONFLICT_ACTION]=update
    CONFIG[ALLOW_DELETIONS]=1
    CONFIG[ALLOW_OVERWRITES]=1
    CONFIG[MAX_ROTATIONS]=
    CONFIG[ROTATIONALS_HARD_LINK]=0
    CONFIG[IDENTICALS_HARD_LINK]=0
    CONFIG[COMPRESS_LOGS]=1
    CONFIG[PRE_SCRIPT]=
    CONFIG[SUCCESS_SCRIPT]=
    CONFIG[FAILED_SCRIPT]=
    CONFIG[FINAL_SCRIPT]=
    CONFIG[PRE_SCRIPT_ERROR_EXIT]=0
    CONFIG[PID_FILE]=.cfgbackup.pid
    CONFIG[RSYNC_PATH]=rsync
    CONFIG[MAIL_PATH]=mail
    CONFIG[HARDLINK_PATH]=hardlink
    CONFIG[SORT_PATH]=sort
    CONFIG[COMPRESS_PATH]=gzip
    CONFIG[MIRROR_PREFIX]=.cfgbackup.mirror
}

###############################
## Parse a value for a given config line
##  $1 -> File to search
##  $2 -> Name of parameter to get value for
## Prints the string value, or empty string if not found
config_param_get() {
    grep -E "^ *$2 *=" $1 | tail -n 1 | cut -d= -f2- | sed 's/ *$//' | sed 's/^ *//'
}

###############################
## Parse config to check if a given parameter exists
##  $1 -> File to search
##  $2 -> Name of parameter to get value for
## Returns 0 if the parameter exists in the file, 1 if it does not
config_param_exists() {
    PARAM_FOUND=$( grep -E "^ *$2 *=" $1 )
    if [[ $PARAM_FOUND != "" ]]; then
        return 0
    fi
    return 1
}

###############################
## Parse config file given
## Returns 0 on success, 1 on error
## Any errors will be in PARSE_ERRORS
parse_config() {
    declare -a PARSE_ERRORS
    default_config

    # Verify config file exists and is readable
    if [[ ! -f $CONFIG_FILE || ! -r $CONFIG_FILE ]]; then
        PARSE_ERRORS+=("Config file doesn't exist or isn't readable.")
    else
        # Parse config file for variables
        for KEY in "${!CONFIG[@]}"; do
            # Get variable values from config file
            CONFIG_VALUE=$(config_param_get $CONFIG_FILE $KEY)
            # If key is NOTIFY_RSYNC_FLAGS, allow for setting value to empty
            if [[ $KEY == "NOTIFY_RSYNC_FLAGS" ]] && config_param_exists $CONFIG_FILE $KEY; then
                : # do nothing
            # If value is empty, leave as default
            elif [[ $CONFIG_VALUE == "" ]]; then
                CONFIG_VALUE=${CONFIG[$KEY]}
            fi
            # Update CONFIG values
            CONFIG[$KEY]=$CONFIG_VALUE
        done

        # Ensure SOURCE_DIR, TARGET_DIR, and BACKUP_TYPE are set
        if [[ ${CONFIG[SOURCE_DIR]} == "" ]]; then
            PARSE_ERRORS+=("Missing required value for SOURCE_DIR.")
        fi
        if [[ ${CONFIG[TARGET_DIR]} == "" ]]; then
            PARSE_ERRORS+=("Missing required value for TARGET_DIR.")
        fi
        if ! [[ ${CONFIG[BACKUP_TYPE]} == "sync" ||  ${CONFIG[BACKUP_TYPE]} == "rotation" || ${CONFIG[BACKUP_TYPE]} == "mirror" ]]; then
            PARSE_ERRORS+=("Invalid value for BACKUP_TYPE; must be sync, rotation, or mirror.")
        fi
        if [[ ${CONFIG[BACKUP_TYPE]} == "rotation" && ( ! ${CONFIG[MAX_ROTATIONS]} =~ ^[0-9]+$ || ${CONFIG[MAX_ROTATIONS]} -lt 2 ) ]]; then
            PARSE_ERRORS+=("Value of MAX_ROTATIONS must be an integer greater than 1 for rotation backups.")
        fi
        if [[ ${CONFIG[BACKUP_TYPE]} == "mirror" && ${CONFIG[MIRROR_CONFLICT_ACTION]} != "update" && ${CONFIG[MIRROR_CONFLICT_ACTION]} != "delete" ]]; then
            PARSE_ERRORS+=("Value of MIRROR_CONFLICT_ACTION must be either update or delete.")
        fi
        read -r -a source_dirs <<< "${CONFIG[SOURCE_DIR]}"
        if [[ ${CONFIG[BACKUP_TYPE]} == "mirror" && ${#source_dirs[@]} -gt 1 ]]; then
            PARSE_ERRORS+=("Backup type of mirror can only have a single SOURCE_DIR directory.")
        fi
        # Ensure ROTATE_SUBDIR is valid
        if [[ ${CONFIG[BACKUP_TYPE]} == "rotation" ]]; then
            MATCH_NUM0=$( substr_index "${CONFIG[ROTATE_SUBDIR]}" "NUM0" )
            MATCH_NUM1=$( substr_index "${CONFIG[ROTATE_SUBDIR]}" "NUM1" )
            MATCH_DATE=$( substr_index "${CONFIG[ROTATE_SUBDIR]}" "DATE" )
            if [[ $MATCH_NUM0 -eq "-1" && $MATCH_NUM1 -eq "-1" && $MATCH_DATE -eq "-1" ]]; then
                PARSE_ERRORS+=("No valid rotation key in ROTATE_SUBDIR. Must include one of: NUM0, NUM1, or DATE")
            fi
        fi
    fi

    if [[ ${#PARSE_ERRORS[@]} -ne 0 ]]; then
        echo "ERROR: Could not parse config file: $CONFIG_FILE"
        for PARSE_MSG in "${PARSE_ERRORS[@]}"; do
            echo $PARSE_MSG
        done
        exit 1
    fi
}

#######################################
# ROTATION FUNCTIONS
#######################################

###############################
## Check if a backup running directory exists in the target directory
## Returns 0 if RUNNING_DIRNAME exists, 1 otherwise
rotate_backup_running() {
    CHECK_RUN=$( path_join "${CONFIG[TARGET_DIR]}" "${CONFIG[RUNNING_DIRNAME]}" )
    if [[ -d $CHECK_RUN ]]; then
        return 0
    fi
    return 1
}

###############################
## Get list of current backup directories, including active/failed dirs
## Ordered by newest backups first, with running/aborted dirs considered newest
## If number of backups exceeds MAX_ROTATIONS, only gets MAX_ROTATIONS directories
## Sets the results in the array: BACKUP_ROTATION_DIRS
## Also records directories past the max in the array: BACKUP_ROTATION_XDIRS
rotate_get_dirs() {
    shopt -s extglob
    declare -g -a BACKUP_ROTATION_DIRS
    declare -g -a BACKUP_ROTATION_XDIRS
    if [[ ${CONFIG[BACKUP_TYPE]} == "rotation" ]]; then
        MATCH_DATE=$( substr_index "${CONFIG[ROTATE_SUBDIR]}" "DATE" )
        SDIR_MATCH=${CONFIG[ROTATE_SUBDIR]};
        SORT_FLAGS="-V"
        if [[ $MATCH_DATE != "-1" ]]; then
            SDIR_MATCH=${SDIR_MATCH//DATE/[0-9]\\\{8\\\}}
            SORT_FLAGS="-V -r"
        else
            # Then try to match exactly
            NUM_RE="NUM(0*)[01][^01]?"
            if [[ ${CONFIG[ROTATE_SUBDIR]} =~ $NUM_RE ]]; then
                NUM_LEN=$(( ${#BASH_REMATCH[1]} + 1 ))
                SDIR_MATCH=${SDIR_MATCH//NUM*(0)+(0|1)/[0-9]\\\{${NUM_LEN}\\\}}\\b
            else
                echo "ERROR: Could not parse NUM variable when matching rotation subdirectories."
                exit 1
            fi
        fi
        LIST_TARGET=$( epath_join ${CONFIG[TARGET_DIR]} )
        readarray BACKUP_ROTATION_DIRS < <( ls -1 ${LIST_TARGET} | grep "\\(${SDIR_MATCH}\\|${CONFIG[RUNNING_DIRNAME]}\\)" | ${CONFIG[SORT_PATH]} $SORT_FLAGS )
        # Ensure running and aborted dirs are listed first
        RUN_IDX=$( array_value_index BACKUP_ROTATION_DIRS ${CONFIG[RUNNING_DIRNAME]} )
        if [[ $RUN_IDX != "-1" ]]; then
            unset BACKUP_ROTATION_DIRS[$RUN_IDX]
            BACKUP_ROTATION_DIRS=( ${CONFIG[RUNNING_DIRNAME]} "${BACKUP_ROTATION_DIRS[@]}" )
        fi
        # Limit to MAX_ROTATIONS
        BACKUP_ROTATION_XDIRS=( "${BACKUP_ROTATION_DIRS[@]:${CONFIG[MAX_ROTATIONS]}}" )
        BACKUP_ROTATION_DIRS=( "${BACKUP_ROTATION_DIRS[@]:0:${CONFIG[MAX_ROTATIONS]}}" )
    fi
}

###############################
## Print the number of backups in target directory, including running/aborted
## If number of backups exceeds MAX_ROTATIONS, returns MAX_ROTATIONS instead
rotate_backup_count() {
    rotate_get_dirs
    echo ${#BACKUP_ROTATION_DIRS[@]}
}

###############################
## Get the name of the most recent non-running rotation directory
## Outputs the directory name, or nothing if no prior backups exist
rotate_current_backup() {
    BACKUP_COUNT=$( rotate_backup_count )
    RECENT_ROT=
    if [[ $BACKUP_COUNT -gt 0 ]]; then
        if [[ ${BACKUP_ROTATION_DIRS[0]} != ${CONFIG[RUNNING_DIRNAME]} ]]; then
            RECENT_ROT=${BACKUP_ROTATION_DIRS[0]}
        elif [[ $BACKUP_COUNT -gt 1 ]]; then
            RECENT_ROT=${BACKUP_ROTATION_DIRS[1]}
        fi
    fi
    echo "$RECENT_ROT"
}

###############################
## Outputs the name of the oldest backup directory that is not older than MAX_ROTATIONS
rotate_oldest_backup() {
    BACKUP_COUNT=$( rotate_backup_count )
    if [[ $BACKUP_COUNT -gt 0 ]]; then
        echo ${BACKUP_ROTATION_DIRS[-1]}
    fi
}

###############################
## Create/rename directory to begin new backup
## Exits script with code 1 on failure
## Returns 0 on new empty run dir created, returns 1 on re-using oldest backup dir
rotate_start() {
    rotate_get_dirs
    ROT_COUNT=$( rotate_backup_count )
    # Check for active directory
    if [[ ${BACKUP_ROTATION_DIRS[0]} == ${CONFIG[RUNNING_DIRNAME]} ]]; then
        echo "ERROR: Running backup directory already exists: ${CONFIG[RUNNING_DIRNAME]}"
        exit 1
    fi

    # Check if at rotation max
    if [[ $ROT_COUNT -eq ${CONFIG[MAX_ROTATIONS]} ]]; then
        log_entry "| At maximum rotation count of ${CONFIG[MAX_ROTATIONS]}"
        # Rename oldest directory for run
        OLDEST_DIR=$( rotate_oldest_backup )
        if [[ $OLDEST_DIR != "" ]]; then
            log_entry "| Renaming: $OLDEST_DIR => ${CONFIG[RUNNING_DIRNAME]}"
            PREV_DIR=$( epath_join ${CONFIG[TARGET_DIR]} ${OLDEST_DIR} )
            mv $PREV_DIR $RUN_DIR
            if [[ $? -ne 0 ]]; then
                echo "ERROR: Could not rotate directory: ${OLDEST_DIR}"
                exit 1
            fi
            return 1
        else
            # One of those "shouldn't be possible" situations
            echo "ERROR: Failed to find old directory to rotate."
            exit 1
        fi
    else
        log_entry "| Found $ROT_COUNT backups out of a max of ${CONFIG[MAX_ROTATIONS]}"
        log_entry "| Creating new directory: ${CONFIG[RUNNING_DIRNAME]}"
        # Create new directory for run
        mkdir $RUN_DIR
        if [[ $? -ne 0 ]]; then
            echo "ERROR: Could not create new rotate directory: ${OLDEST_DIR}"
            exit 1
        fi
        return 0
    fi
}

###############################
## Given a running directory, move it back to the end of rotation list
rotate_reset() {
    MATCH_NUM0=$( substr_index "${CONFIG[ROTATE_SUBDIR]}" "NUM0" )
    MATCH_DATE=$( substr_index "${CONFIG[ROTATE_SUBDIR]}" "DATE" )
    if [[ $MATCH_DATE != "-1" ]]; then
        rotate_reset_date
    elif [[ $MATCH_NUM0 != "-1" ]]; then
        RE0="NUM(0*)0[^01]?"
        RE1="NUM(0+)1"
        if [[ ${CONFIG[ROTATE_SUBDIR]} =~ $RE1 ]]; then
            rotate_reset_num "1" ${#BASH_REMATCH[1]}
        elif [[ ${CONFIG[ROTATE_SUBDIR]} =~ $RE0 ]]; then
            rotate_reset_num "0" ${#BASH_REMATCH[1]}
        else
            echo "ERROR: Unexpected rotate directory variable name"
            exit 1
        fi
    else
        rotate_reset_num "1"
    fi
}

###############################
## Given a running directory, move it back to the oldest date named rotation
rotate_reset_date() {
    if [[ -d $RUN_DIR ]]; then
        OLDEST_DIR="${BACKUP_ROTATION_DIRS[-1]}"
        DATE_MATCHER=${CONFIG[ROTATE_SUBDIR]/DATE/"([[:digit:]]{8})"}
        OLDEST_DATE=${BASH_REMATCH[1]}
        USE_DATE=$( date +%Y%m%d -d "$OLDEST_DATE" )

        CHECK_SUB=${CONFIG[ROTATE_SUBDIR]/DATE/$USE_DATE}
        CHECK_DIR=$( epath_join ${CONFIG[TARGET_DIR]} ${CHECK_SUB} )
        if [[ -d $CHECK_DIR ]]; then
            USE_DATE=$OLDEST_DATE
            USE_DATE=$( date +%Y%m%d -d "$OLDEST_DATE -1day" )
            CHECK_SUB=${CONFIG[ROTATE_SUBDIR]/DATE/$USE_DATE}
            CHECK_DIR=$( epath_join ${CONFIG[TARGET_DIR]} ${CHECK_SUB} )
        fi
        if [[ -d $CHECK_DIR ]]; then
            CHECK_DIR=$( epath_join ${CONFIG[TARGET_DIR]} "${CHECK_SUB}.0" )
        fi

        echo "Renaming: ${CONFIG[RUNNING_DIRNAME]} => $( basename $CHECK_DIR )"
        # Rename to complete dir
        mv $RUN_DIR $CHECK_DIR
        if [[ $? -ne 0 ]]; then
            echo "ERROR: Could not reset directory: ${RUN_DIR}"
            exit 1
        fi
    fi
}

###############################
## Given a running directory, move it back to the oldest number based rotation
##  $1 -> Starting number to represent most recent backup; must be 0 or 1
##  $2 -> Number of left-padded zeroes; default of 0
rotate_reset_num() {
    if [[ -d $RUN_DIR ]]; then
        MAX_NUM=$(( $1 + ${CONFIG[MAX_ROTATIONS]} - 1 ))
        RESET_DIR=$( rotate_subdir_num $MAX_NUM $2 )
        if [[ -d $RESET_DIR ]]; then
            echo "ERROR: Can't reset! Final rotation dir already exists: $RESET_DIR"
            exit 1
        fi
        echo "Renaming: ${CONFIG[RUNNING_DIRNAME]} => $( basename $RESET_DIR )"
        mv $RUN_DIR $RESET_DIR
        if [[ $? -ne 0 ]]; then
            echo "ERROR: Could not rename directory to: ${RESET_DIR}"
            exit 1
        fi
    fi
}

###############################
## Rotate directories after backup completes and rename running directory
rotate_complete() {
    MATCH_NUM0=$( substr_index "${CONFIG[ROTATE_SUBDIR]}" "NUM0" )
    MATCH_DATE=$( substr_index "${CONFIG[ROTATE_SUBDIR]}" "DATE" )
    if [[ $MATCH_DATE != "-1" ]]; then
        rotate_complete_date
    elif [[ $MATCH_NUM0 != "-1" ]]; then
        RE0="NUM(0*)0[^01]?"
        RE1="NUM(0+)1"
        if [[ ${CONFIG[ROTATE_SUBDIR]} =~ $RE1 ]]; then
            rotate_complete_num "1" ${#BASH_REMATCH[1]}
        elif [[ ${CONFIG[ROTATE_SUBDIR]} =~ $RE0 ]]; then
            rotate_complete_num "0" ${#BASH_REMATCH[1]}
        else
            echo "ERROR: Unexpected rotate directory variable name"
            exit 1
        fi
    else
        rotate_complete_num "1"
    fi
}

###############################
## Having completed a running backup, rename running directory to a date based directory
rotate_complete_date() {
    TODAY=$( date +%Y%m%d )
    COMPL_SUB=${CONFIG[ROTATE_SUBDIR]/DATE/$TODAY}
    COMPL_DIR=$( epath_join ${CONFIG[TARGET_DIR]} ${COMPL_SUB} )
    COMPL_EXT=0
    # If oldest backup is already for todays date, start from that
    RECENT_DIR=$( rotate_current_backup )
    MATCH_RECENT=$( substr_index "${RECENT_DIR}" "${COMPL_SUB}." )
    if [[ $MATCH_RECENT != "-1" ]]; then
        COMPL_EXT=${RECENT_DIR#${COMPL_SUB}.}
        COMPL_DIR=$( epath_join ${CONFIG[TARGET_DIR]} "${COMPL_SUB}.${COMPL_EXT}" )
    fi
    # Check if complete dir already exists (with some sanity limits)
    while [[ -d $COMPL_DIR && $COMPL_EXT -le 1499 ]]; do
        # If exists, append .1, .2, .3, etc to complete dir
        COMPL_EXT=$(( COMPL_EXT + 1 ))
        COMPL_DIR=$( epath_join ${CONFIG[TARGET_DIR]} "${COMPL_SUB}.${COMPL_EXT}" )
    done
    # Too many backups!
    if [[ $COMPL_EXT -gt 1499 ]]; then
        echo "ERROR: Too many backups for single date (Max of 1499): ${TODAY}"
        exit 1
    fi
    log_entry "| Renaming: ${CONFIG[RUNNING_DIRNAME]} => $( basename $COMPL_DIR )"
    # Rename to complete dir
    mv $RUN_DIR $COMPL_DIR
    if [[ $? -ne 0 ]]; then
        echo "ERROR: Could not rename completed backup to: ${COMPL_DIR}"
        exit 1
    fi
    touch $COMPL_DIR
}

###############################
## Shortcut function to create an escaped fullpath for a given num dir
##  $1 -> Num of subdir
##  $2 -> Number of left-padded zeroes
## Outputs the escaped full path
rotate_subdir_num() {
    NUM=$( printf "%0$(( $2 + 1 ))d" $1 )
    NUMDIR=$( echo ${CONFIG[ROTATE_SUBDIR]} | sed "s/NUM0*[01]/$NUM/" )
    FULL_SUBDIR=$( epath_join ${CONFIG[TARGET_DIR]} ${NUMDIR} )
    echo $FULL_SUBDIR
}

###############################
## Having completed a running backup, rotate number based subdirectories
##  $1 -> Starting number to represent most recent backup; must be 0 or 1
##  $2 -> Number of left-padded zeroes; default of 0
rotate_complete_num() {
    FIRST_N=$1
    PAD=${2:-0}
    LAST_N=$(( $FIRST_N + ${CONFIG[MAX_ROTATIONS]} - 1 ))
    # Attempt to locate a gap
    GAP_N=""
    for N in $( seq $FIRST_N $LAST_N ); do
        GAP_DIR=$( rotate_subdir_num $N $PAD)
        if [[ ! -d $GAP_DIR ]]; then
            GAP_N=$N
            break
        fi
    done
    if [[ $GAP_N != "" ]]; then
        LAST_N=$GAP_N
    fi
    # If last directory already exists, we cannot rotate
    LAST_DIR=$( rotate_subdir_num $LAST_N $PAD )
    if [[ -d $LAST_DIR ]]; then
        echo "ERROR: Could not rotate due to directory already existing: ${LAST_DIR}"
        exit 1
    fi
    # Rotate directories
    for N in $( seq $(( LAST_N - 1 )) -1 $FIRST_N ); do
        ROT_FROM=$( rotate_subdir_num $N $PAD )
        ROT_TO=$( rotate_subdir_num $(( N + 1 )) $PAD )
        log_entry "| Renaming: $( basename $ROT_FROM ) => $( basename $ROT_TO )"
        mv $ROT_FROM $ROT_TO
        if [[ $? -ne 0 ]]; then
            echo "ERROR: Failed to rotate directory from ${ROT_FROM} to ${ROT_TO}"
            exit 1
        fi
    done
    # Rename running dir
    FIRST_DIR=$( rotate_subdir_num $FIRST_N $PAD )
    log_entry "| Renaming: ${CONFIG[RUNNING_DIRNAME]} => $( basename $FIRST_DIR )"
    mv $RUN_DIR $FIRST_DIR
    if [[ $? -ne 0 ]]; then
        echo "ERROR: Could not rename directory from ${RUN_DIR} to ${FIRST_DIR}"
        exit 1
    fi
    touch $FIRST_DIR
}

#######################################
# MIRROR SUPPORT FUNCTIONS
#######################################

###############################
## Create a listing of all files in a directory
##  $1 -> Either a local directory path or an remote SSH directory location
## Outputs list of files
mirror_create_filelist() {
    local FSETDIR="$1"
    local FILELIST_CMD=""
    dirpath_is_remote "${FSETDIR}"
    local DP_REMOTE=$?
    if [[ $DP_REMOTE == 0 ]]; then
        local COLON_IDX=$( substr_index "${FSETDIR}" ":" )+1
        local SSH_CONNECT=${FSETDIR:0:$COLON_IDX}
        FSETDIR=${FSETDIR:1+$COLON_IDX}
        # Add ssh connection prefix
        FILELIST_CMD="ssh -o BatchMode=yes $SSH_CONNECT"
    fi

    # Don't include cfgbackup files
    SRC_LIST_FILE=${CONFIG[MIRROR_PREFIX]}.source
    TGT_LIST_FILE=${CONFIG[MIRROR_PREFIX]}.target

    FSETDIR="${FSETDIR%/}/"

    # Listing creation command
    FIND_SUBCMD="find $FSETDIR ! -path $PID_FULL ! -path ${FSETDIR}${TGT_LIST_FILE} ! -path ${FSETDIR}/${SRC_LIST_FILE} -exec ls -dn --quoting-style=escape --full-time {} \;"
    AWK_SUBCMD="awk '/^total/ {next}; { gsub(\"$FSETDIR\",\"./\",\$9); printf(\"%s%s %s\",\$6,\$7,\$5); for (i=9;i<=NF;i++) printf(\" %s\",\$i); printf(\"\\n\"); }'"
    FILELIST_CMD="$FILELIST_CMD $FIND_SUBCMD | $AWK_SUBCMD"

    # Run command
    eval $FILELIST_CMD
    FILELIST_EXIT=$?
    if [[ $FILELIST_EXIT != 0 ]]; then
        echo "ERROR: Failed to generate mirror file listing from: $1"
        exit 1
    fi
}

###############################
## Create a file and save the contents of the variable to the file
##  $1 -> The variable name with the contents to put int the file
## Outputs name of file containing contents of the variable
file_from_var() {
    local TMPVARFILE=$( mktemp )
    echo -n "${!1}" > $TMPVARFILE
    echo $TMPVARFILE
}

###############################
## Compare contents of two variables pre-sorted line by line, outputing lines unique to the first variable
##  $1 -> Name of first variable
##  $2 -> Name of second variable
## Outputs lines unique to the first variable
linecomp_unique_first() {
    local FIRST_FILE=$( file_from_var "$1" )
    local SECOND_FILE=$( file_from_var "$2" )
    local COMM_RESULT=$( comm -2 -3 $FIRST_FILE $SECOND_FILE )
    rm $FIRST_FILE
    rm $SECOND_FILE
    echo "$COMM_RESULT"
}

###############################
## Compare contents of two variables pre-sorted line by line, outputing lines that appear the same in both variables
##  $1 -> Name of first variable
##  $2 -> Name of second variable
## Outputs lines identical to both variables
linecomp_identical() {
    local FIRST_FILE=$( file_from_var "$1" )
    local SECOND_FILE=$( file_from_var "$2" )
    local COMM_RESULT=$( comm -1 -2 $FIRST_FILE $SECOND_FILE )
    rm $FIRST_FILE
    rm $SECOND_FILE
    echo "$COMM_RESULT"
}

###############################
## Remove all lines from the first variable that have a line ending that matches a line from the second variable
##  $1 -> Name of first variable
##  $2 -> Name of second variable (contains lines endings to exclude)
## Outputs lines from the first variable that do not match ending from the second variable
remove_lines_ending_with() {
    GREP_EXCLUDE=$( mktemp )
    echo "${!2}" | sed 's/[^a-zA-Z0-9]/\\&/g' | awk 'NF > 0 { print $0 "$"; }' > $GREP_EXCLUDE
    echo "${!1}" | grep -v -f $GREP_EXCLUDE
    rm $GREP_EXCLUDE
}

#######################################
# CHECK CONFIG FILE OPTIONS
#######################################

###############################
## Check if directory path indicates it is remote
##  $1 -> Path to directory
## Return 0 if remote; 1 otherwise
dirpath_is_remote() {
    DIRPATH="$1"
    local COLON_IDX=$( substr_index "${DIRPATH}" ":" )
    local SLASH_IDX=$( substr_index "${DIRPATH}" "/" )
    if [[ $COLON_IDX -ge 0 && $COLON_IDX -lt $SLASH_IDX ]]; then
        return 0
    fi
    return 1
}

###############################
## Run checks on config and access
command_check() {
    # Test log access
    log_can_write
    if [[ $? -ne 0 ]]; then
        echo "ERROR: Cannot write to log directory of ${CONFIG[LOG_DIR]}"
        exit 1
    fi

    # Test source access
    read -r -a SOURCE_DIRS <<< "${CONFIG[SOURCE_DIR]}"
    LAST_SSH_CONNECT=
    for SRC_DIR in "${SOURCE_DIRS[@]}"; do
        dirpath_is_remote "${SRC_DIR}"
        if [[ $? -eq 0 ]]; then
            local COLON_IDX=$( substr_index "${SRC_DIR}" ":" )
            local SSH_CONNECT=${SRC_DIR:0:$COLON_IDX}
            local SSH_SOURCE=${SRC_DIR:1+$COLON_IDX}
            if [[ -z $SSH_CONNECT ]]; then
                SSH_CONNECT=$LAST_SSH_CONNECT
            fi
            # Check SSH connection
            ssh -o BatchMode=yes $SSH_CONNECT exit 0
            if [[ $? != 0 ]]; then
                echo "ERROR: Could not connect via SSH to ${SSH_CONNECT}"
                exit 1
            fi
            LAST_SSH_CONNECT=$SSH_CONNECT

            # Check remote directory
            ssh -o BatchMode=yes $LAST_SSH_CONNECT "[[ ! -d $SSH_SOURCE || ! -r $SSH_SOURCE ]]"
            if [[ $? -eq 0 ]]; then
                echo "ERROR: Cannot read from remote source directory of ${SSH_SOURCE}"
                exit 1
            fi
        else
            # Check local directory
            if [[ ! -d ${SRC_DIR} || ! -r ${SRC_DIR} ]]; then
                echo "ERROR: Cannot read from local source directory of ${SRC_DIR}"
                exit 1
            fi
        fi
    done

    # Test target access
    if [[ ! -d ${CONFIG[TARGET_DIR]} || ! -w ${CONFIG[TARGET_DIR]} ]]; then
        echo "ERROR: Cannot write to target directory of ${CONFIG[TARGET_DIR]}"
        exit 1
    fi

    # Check if hardlink is available if IDENTICALS_HARD_LINK is set
    if [[ ${CONFIG[IDENTICALS_HARD_LINK]} == "1" || ${CONFIG[IDENTICALS_HARD_LINK]} == "2" ]]; then
        if ! hardlink_exists; then
            echo "ERROR: Option IDENTICALS_HARD_LINK is set, but hardlink binary could not be found."
            exit 1
        fi
    fi
}

#######################################
# STATUS COMMAND
#######################################

###############################
## Check if the config is not busy
## Returns 1 if running, failed, or has uncleanly died, 0 otherwise
status_is_ready() {
    if status_is_running || status_is_failed || status_is_dead; then
        return 1
    fi
    return 0
}

###############################
## Check if the config is busy
## Returns 0 if running, failed, or has uncleanly died, 1 otherwise
status_is_busy() {
    if status_is_running || status_is_failed || status_is_dead; then
        return 0
    fi
    return 1
}

###############################
## Check if the backup is successfully running
## Returns 0 if job is running and a pid file exists and a process with matching pid exists, 1 otherwise
status_is_running() {
    if [[ -d $RUN_DIR && -f $PID_FULL ]]; then
        PID=$( cat $PID_FULL )
        ps -p $PID > /dev/null
        PID_FOUND=$?
        if [[ $PID_FOUND -eq 0 ]]; then
            return 0
        fi
    fi
    return 1
}

###############################
## Check if the backup did not complete and exited uncleanly
## Returns 0 if running directory exists and pid file exists without any matching process for that pid; 1 otherwise
status_is_dead() {
    if [[ -d $RUN_DIR && -f $PID_FULL ]]; then
        PID=$( cat $PID_FULL )
        ps -p $PID > /dev/null
        PID_FOUND=$?
        if [[ $PID_FOUND -ne 0 ]]; then
            return 0
        fi
    fi
    return 1
}

###############################
## Check if the backup did not complete, but exited cleanly.
## Returns 0 if running directory exists and there is no pid file; always returns 1 for sync jobs
status_is_failed() {
    if [[ ${CONFIG[BACKUP_TYPE]} == "rotation" && -d $RUN_DIR && ! -f $PID_FULL ]]; then
        return 0;
    fi
    return 1
}

###############################
## Run status report
command_status() {
    CONFIG_STAT="idle"
    if status_is_running; then
        CONFIG_STAT="running"
    elif status_is_failed; then
        CONFIG_STAT="failed - see log"
    elif status_is_dead; then
        CONFIG_STAT="process died uncleanly"
    fi

    JOB_STARTED="-"
    if [[ -f $PID_FULL ]]; then
        JOB_STARTED=$( date -r $PID_FULL +%Y-%m-%d\ %H:%M:%S )
    fi
    PID_NUM="-"
    if status_is_running; then
        PID_NUM=$( cat $PID_FULL )
    fi
    rotate_get_dirs
    LAST_BACKUP_DIR=$( rotate_current_backup )
    if [[ ! -z $LAST_BACKUP_DIR ]]; then
        LAST_BACKUP_DIR=$( epath_join ${CONFIG[TARGET_DIR]} $LAST_BACKUP_DIR )
    fi

    if [[ ${CONFIG[BACKUP_TYPE]} == "sync" ]]; then
        LAST_BACKUP_DIR=$RUN_DIR
    fi

    echo "======= cfgbackup job status ======="
    echo "Config:               $( basename $CONFIG_FILE )"
    echo "Type:                 ${CONFIG[BACKUP_TYPE]}"
    echo "Status:               $CONFIG_STAT"
    echo "Started:              $JOB_STARTED"
    echo "Process ID:           $PID_NUM"
    if [[ ! -z $LAST_BACKUP_DIR ]]; then
        if [[ ${CONFIG[BACKUP_TYPE]} != "sync" ]]; then
            echo "Last complete job:    $( basename $LAST_BACKUP_DIR )"
        fi
        echo "Last complete time:   $( date -r $LAST_BACKUP_DIR +%Y-%m-%d\ %H:%M:%S )"
    fi
    echo ""
    LAST_LOGFILE=$( log_last_file )
    if [[ ! -z $LAST_LOGFILE ]]; then
        echo "Log file:             $( basename $LAST_LOGFILE )"
        echo "Latest log messages:"
        tail -n 4 $LAST_LOGFILE | sed 's/^/  /'
    fi
}

#######################################
# RUN COMMAND
#######################################

###############################
## Run backup job
command_run() {
    if status_is_busy; then
        echo "ERROR: Cannot start new backup job if previous job is not completed."
        exit 1
    fi

    # Record run pid in target dir cfgbackup.pid file
    log_entry "| JOB STARTED:  $( date +%Y-%m-%d\ %H:%M:%S )"
    command_runscript PRE_SCRIPT
    if [[ ${CONFIG[BACKUP_TYPE]} == "rotation" ]]; then
        runjob_rotation
    elif [[ ${CONFIG[BACKUP_TYPE]} == "sync" ]]; then
        runjob_sync
    elif [[ ${CONFIG[BACKUP_TYPE]} == "mirror" ]]; then
        runjob_mirror
    fi
    command_runscript FINAL_SCRIPT
    command_end
}

###############################
## End job and clean up the pid file
command_end() {
    log_entry "| JOB ENDED: $( date +%Y-%m-%d\ %H:%M:%S )"
    # Cleanup by removing cfgbackup.pid file
    rm $PID_FULL
}

###############################
## Run given script specified by the config, or do nothing if no script was set
## Will send email notice if script returns non 0 exit code
##  $1 -> Name of config script line to find
command_runscript() {
    ALLOWED_SCRIPTS=( PRE_SCRIPT SUCCESS_SCRIPT FAILED_SCRIPT FINAL_SCRIPT )
    array_contains ALLOWED_SCRIPTS $1
    FOUND_SCPT=$?
    if [[ $FOUND_SCPT -eq 0 && ! -z ${CONFIG[$1]} ]]; then
        log_entry "| Running $1: ${CONFIG[$1]}"
        SCRIPT_OUT=$( {
            eval "${CONFIG[$1]}"
        } >> $LOG_FILE 2>&1 )
        SCRIPT_RET=$?
        if [[ $SCRIPT_RET -ne 0 ]]; then
            log_entry "| Script returned exit code: $SCRIPT_RET"
            # Send notify email about script failure
            mailer "${CONFIG[NOTIFY_EMAIL]}" "cfgbackup job '${CONF_NAME}' had $1 script failure" "The $1 ( ${CONFIG[$1]} ) for job '${CONF_NAME}' failed with exit code ${SCRIPT_RET}. See logs for details."
            if [[ $1 == "PRE_SCRIPT" && ${CONFIG[PRE_SCRIPT_ERROR_EXIT]} -eq 1 ]]; then
                log_entry "| PRE_SCRIPT failed and PRE_SCRIPT_ERROR_EXIT is set; exiting."
                log_entry "| JOB ENDED: $( date +%Y-%m-%d\ %H:%M:%S )"
                exit 1
            fi
        fi
    fi
}

###############################
## Runs a 'hardlink' process to link identical files together in the
## running directory.
## Does nothing if IDENTICAL_HARD_LINKS is not set.
hardlink_identicals() {
    if [[ ${CONFIG[IDENTICALS_HARD_LINK]} == "1" || ${CONFIG[IDENTICALS_HARD_LINK]} == "2" ]]; then
        log_entry "| Attempting to hardlink identical files..."
        HARDLINK_CONTENT_FLAG=''
        if [[ ${CONFIG[IDENTICALS_HARD_LINK]} == "2" ]]; then
            HARDLINK_CONTENT_FLAG=' -c'
        fi
        HARDLINK_COMMAND="${CONFIG[HARDLINK_PATH]}${HARDLINK_CONTENT_FLAG} ${RUN_DIR}"
        log_entry "| Running command: $HARDLINK_COMMAND"
        HARDLINK_COMMAND="$HARDLINK_COMMAND >> ${LOG_FILE} 2>&1"
        HARDLINK_RET=$?
        if [[ $HARDLINK_RET -ne 0 ]]; then
            log_entry "| Hardlink command returned exit code: $HARDLINK_RET"
        fi
    fi
}

###############################
## Escape the rsync source path, including the user and host for remote ssh sources
## Output the escaped path
escaped_rsync_source() {
    read -r -a SOURCE_DIRS <<< "${CONFIG[SOURCE_DIR]}"
    ESCPATH=
    for SRC_DIR in "${SOURCE_DIRS[@]}"; do
        TRAILSLASH=${SRC_DIR: -1}
        if [[ $TRAILSLASH != "/" ]]; then
            TRAILSLASH=
        fi
        ESCSRCPATH="$( epath_join ${SRC_DIR} )${TRAILSLASH}"
        dirpath_is_remote "${SRC_DIR}"
        if [[ $? == 0 ]]; then
            local COLON_IDX=$( substr_index "${SRC_DIR}" ":" )
            local SSH_CONNECT=${SRC_DIR:0:$COLON_IDX}
            local SSH_SOURCE=${SRC_DIR:1+$COLON_IDX}
            ESCSRCPATH="${SSH_CONNECT}:\"$( epath_join "$SSH_SOURCE" )${TRAILSLASH}\""
        fi
        ESCPATH="${ESCPATH} ${ESCSRCPATH}"
    done
    echo "$ESCPATH"
}

###############################
## Run a sync job
runjob_sync() {
    echo $$ > $PID_FULL
    log_entry "| Job type: sync"
    SYNC_FROM=$( escaped_rsync_source )

    RSYNC_FLAGS="-av --stats ${CONFIG[RSYNC_FLAGS]}"
    if [[ ${CONFIG[ALLOW_DELETIONS]} == "1" ]]; then
        RSYNC_FLAGS="$RSYNC_FLAGS --del"
    fi
    if [[ ${CONFIG[ALLOW_OVERWRITES]} == "0" ]]; then
        RSYNC_FLAGS="$RSYNC_FLAGS --ignore-existing"
    fi
    # Exclude PID_FILE from being synced
    RSYNC_FLAGS="${RSYNC_FLAGS} --exclude=/${PID_FILE}"

    RSYNC_COMMAND="${CONFIG[RSYNC_PATH]} ${RSYNC_FLAGS} ${SYNC_FROM} ${RUN_DIR}/"
    log_entry "| Running rsync: $RSYNC_COMMAND"
    RSYNC_COMMAND="$RSYNC_COMMAND >> ${LOG_FILE} 2>&1"
    eval $RSYNC_COMMAND
    RSYNC_EXIT=$?
    if [[ $RSYNC_EXIT -ne 0 ]]; then
        log_entry "| Rsync command exited with code: $RSYNC_EXIT"
        command_runscript FAILED_SCRIPT
        mailer_rsync_exit $RSYNC_EXIT
    else
        hardlink_identicals
        command_runscript SUCCESS_SCRIPT
    fi

    # If ALLOW_DELETIONS or ALLOW_OVERWRITES is 0, check for skipped files
    if [[ ${CONFIG[ALLOW_DELETIONS]} == "0" || ${CONFIG[ALLOW_OVERWRITES]} == "0" ]]; then
        runjob_skipped_files
    fi

    # Update timestamp of target dir to indicate backup time
    touch $RUN_DIR
}

###############################
## Run a rotate job
runjob_rotation() {
    log_entry "| Job type: rotation"
    rotate_start
    NEW_RUNDIR=$?
    echo $$ > $PID_FULL

    RSYNC_FLAGS="-av --stats ${CONFIG[RSYNC_FLAGS]}"
    if [[ ${CONFIG[ALLOW_DELETIONS]} == "1" ]]; then
        RSYNC_FLAGS="$RSYNC_FLAGS --del"
    fi
    if [[ ${CONFIG[ALLOW_OVERWRITES]} == "0" ]]; then
        RSYNC_FLAGS="$RSYNC_FLAGS --ignore-existing"
    fi

    if [[ ${CONFIG[ROTATIONALS_HARD_LINK]} == "1" ]]; then
        # Get previous directory for target of link-dest, or skip if no previous backup dir
        PREV_BACKUP=$( rotate_current_backup )
        if [[ $PREV_BACKUP != "" ]]; then
            log_entry "| Hard linking identical files from: $PREV_BACKUP"
            PREV_BACKUP_PATH=$( epath_join "${CONFIG[TARGET_DIR]}" "$PREV_BACKUP" )
            RSYNC_FLAGS="${RSYNC_FLAGS} --link-dest=${PREV_BACKUP_PATH}"
            # If using old version of rsync (prior to 3.1.0), we must manually link files from
            # the previous backup dir; version 3.1.0 and later works with just the link-dest flag above
            if ! rsync_gte_310; then
                log_entry "| Old version of rsync detected, consider upgrading! Manually linking from previous rotation..."
                pushd ${PREV_BACKUP_PATH} > /dev/null
                if [[ $? -eq 0 ]]; then
                    # Create missing directories in RUN_DIR
                    # Compare files between PREV_BACKUP and RUN_DIR, hard link if different
                    find . \
                    \( \
                        -type d -exec mkdir -p ${RUN_DIR}/{} \; \
                        -o \
                        -type f \
                        \( \
                            -exec cmp -s {} ${RUN_DIR}/{} \; \
                            -o \
                            -exec ln -f {} ${RUN_DIR}/{} \; \
                        \) \
                    \)
                    popd > /dev/null
                fi
            fi
        fi
    fi

    SYNC_FROM=$( escaped_rsync_source )
    RSYNC_COMMAND="${CONFIG[RSYNC_PATH]} ${RSYNC_FLAGS} ${SYNC_FROM} ${RUN_DIR}/"
    log_entry "| Running rsync: $RSYNC_COMMAND"
    RSYNC_COMMAND="$RSYNC_COMMAND >> ${LOG_FILE} 2>&1"
    eval $RSYNC_COMMAND
    RSYNC_EXIT=$?
    # On any error (except 24), send email report
    if [[ $RSYNC_EXIT -gt 0 && $RSYNC_EXIT -ne 24 ]]; then
        log_entry "| Rsync command exited with code: $RSYNC_EXIT"
        command_runscript FAILED_SCRIPT
        mailer_rsync_exit $RSYNC_EXIT
        return
    else
        hardlink_identicals
        command_runscript SUCCESS_SCRIPT
    fi

    # If ALLOW_DELETIONS or ALLOW_OVERWRITES is 0, check for skipped files
    if [[ ${CONFIG[ALLOW_DELETIONS]} == "0" || ${CONFIG[ALLOW_OVERWRITES]} == "0" ]]; then
        runjob_skipped_files
    fi

    # Update timestamp of target dir to indicate backup time
    touch $RUN_DIR

    rotate_complete
}

###############################
## Generate an email report of skipped files, and log them as well
runjob_skipped_files() {
    RSYNC_FLAGS="-ai --dry-run --existing ${CONFIG[RSYNC_FLAGS]} ${CONFIG[NOTIFY_RSYNC_FLAGS]}"
    if [[ ${CONFIG[ALLOW_DELETIONS]} == "0" ]]; then
        RSYNC_FLAGS="$RSYNC_FLAGS --del"
    fi
    if [[ ${CONFIG[ALLOW_OVERWRITES]} != "0" ]]; then
        RSYNC_FLAGS="$RSYNC_FLAGS --ignore-existing"
    fi
    # Exclude PID_FILE from being synced
    if [[ ${CONFIG[BACKUP_TYPE]} == "sync" ]]; then
        RSYNC_FLAGS="${RSYNC_FLAGS} --exclude=/${PID_FILE}"
    fi

    RSYNC_COMMAND="${CONFIG[RSYNC_PATH]} ${RSYNC_FLAGS} ${SYNC_FROM} ${RUN_DIR}/"
    log_entry "| Checking for skipped files..."
    log_entry "| Running rsync: $RSYNC_COMMAND"
    SKIP_RESULTS=$( $RSYNC_COMMAND | tee -a $LOG_FILE 2>&1 )
    RSYNC_EXIT=${PIPESTATUS[0]}
    SKIP_COUNT=$( echo "$SKIP_RESULTS" | wc -l )

    # On any error, send email report
    if [[ $RSYNC_EXIT -gt 0 ]]; then
        log_entry "| Rsync command exited with code: $RSYNC_EXIT"
    fi

    if [[ $SKIP_COUNT -gt 5000 ]]; then
        # If number of skipped files is too large, just list a summary count
        SKIP_RESULTS="
Skipped ${SKIP_COUNT} files from being altered based off limitations set in the '${CONF_FILE_BASE}' config file.

For specifics, see the log file at:
  ${LOG_FILE}"
    elif [[ -n $SKIP_RESULTS && $SKIP_COUNT -gt 0 ]]; then
        # Send list of skipped files in the email
        SKIP_RESULTS="
Skipped ${SKIP_COUNT} files from being altered based off limitations set in the '${CONF_FILE_BASE}' config file.

$SKIP_RESULTS
"
    fi

    # If any files were skipped, send an email report
    if [[ -n $SKIP_RESULTS && ${CONFIG[NOTIFY_EMAIL]} != "" ]]; then
        mailer "${CONFIG[NOTIFY_EMAIL]}" "cfgbackup job '${CONF_NAME}' skipped some files" "$SKIP_RESULTS"
    fi
}

###############################
## Run a mirror job
runjob_mirror() {
    echo $$ > $PID_FULL
    log_entry "| Job type: mirror"
    MIRROR_SRC=$( escaped_rsync_source )

    RSYNC_FLAGS="-av --stats ${CONFIG[RSYNC_FLAGS]}"
    SRC_LIST_FILE=${CONFIG[MIRROR_PREFIX]}.source
    TGT_LIST_FILE=${CONFIG[MIRROR_PREFIX]}.target
    SRC_LIST_FULL=${RUN_DIR}/${SRC_LIST_FILE}
    TGT_LIST_FULL=${RUN_DIR}/${TGT_LIST_FILE}
    # Exclude PID_FILE and mirror files from being synced
    RSYNC_FLAGS="${RSYNC_FLAGS} --exclude=/${PID_FILE} --exclude=/${SRC_LIST_FILE} --exclude=/${TGT_LIST_FILE}"

    MIRROR_FAILURE=0

    # Record start time (to identify new files/modifications made since we started)
    NEW_STARTTIME=$( date --utc '+%Y-%m-%d %T.%N' )

    # Load old file lists
    SRC_LIST_OLD=$( cat $SRC_LIST_FULL 2> /dev/null )
    SRC_LIST_EXISTS=$?
    TGT_LIST_OLD=$( cat $TGT_LIST_FULL 2> /dev/null )
    TGT_LIST_EXISTS=$?

    # Build new file lists
    SRC_LIST_NEW=$( mirror_create_filelist $MIRROR_SRC )
    TGT_LIST_NEW=$( mirror_create_filelist $RUN_DIR )
    # If list file(s) was missing, then skip all changes
    if [[ $SRC_LIST_EXISTS -eq 0 && $TGT_LIST_EXISTS -eq 0 ]]; then
        OLD_STARTTIME=$( date --utc '+%Y-%m-%d %T.%N' -r $SRC_LIST_FULL )

        SRC_PATHS_OLD=$( echo "$SRC_LIST_OLD" | cut -d ' ' -f 3- | sort )
        SRC_PATHS_NEW=$( echo "$SRC_LIST_NEW" | cut -d ' ' -f 3- | sort )
        TGT_PATHS_OLD=$( echo "$TGT_LIST_OLD" | cut -d ' ' -f 3- | sort )
        TGT_PATHS_NEW=$( echo "$TGT_LIST_NEW" | cut -d ' ' -f 3- | sort )

        # Identify files removed from source
        SRC_FILES_REMOVED=$( linecomp_unique_first SRC_PATHS_OLD SRC_PATHS_NEW )

        # Identify files removed from target
        TGT_FILES_REMOVED=$( linecomp_unique_first TGT_PATHS_OLD TGT_PATHS_NEW )

        # Reorder file lists for modification comparision
        AWK_REORDER="awk '{ for (i=3;i<=NF;i++) printf(\"%s \",\$i); printf(\"%s %s\",\$1,\$2); printf(\"\\n\"); }'"
        SRC_REORDER_OLD=$( echo "$SRC_LIST_OLD" | eval "$AWK_REORDER" | sort )
        SRC_REORDER_NEW=$( echo "$SRC_LIST_NEW" | eval "$AWK_REORDER" | sort )
        TGT_REORDER_OLD=$( echo "$TGT_LIST_OLD" | eval "$AWK_REORDER" | sort )
        TGT_REORDER_NEW=$( echo "$TGT_LIST_NEW" | eval "$AWK_REORDER" | sort )

        # Identify modified files on source (find changes | trim size/timestamp | exclude removed files)
        SRC_REORDERED=$( linecomp_unique_first SRC_REORDER_OLD SRC_REORDER_NEW )
        SRC_REORDERED=$( echo "$SRC_REORDERED" | awk 'NF > 0 {NF-=2; print $0}' | sort )
        SRC_FILES_MODIFIED=$( linecomp_unique_first SRC_REORDERED SRC_FILES_REMOVED )

        # Identify modified files on target (excluding removed files)
        TGT_REORDERED=$( linecomp_unique_first TGT_REORDER_OLD TGT_REORDER_NEW )
        TGT_REORDERED=$( echo "$TGT_REORDERED" | awk 'NF > 0 {NF-=2; print $0}' | sort )
        TGT_FILES_MODIFIED=$( linecomp_unique_first TGT_REORDERED TGT_FILES_REMOVED )

        # On conflict (one side updated, one side deleted), resolve by MIRROR_CONFLICT_ACTION setting
        CONFLICT_TGT_REMOVED=$( linecomp_identical SRC_FILES_MODIFIED TGT_FILES_REMOVED )
        CONFLICT_SRC_REMOVED=$( linecomp_identical TGT_FILES_MODIFIED SRC_FILES_REMOVED )

        CONFLICT_TGT_REMOVED_FILE=$( file_from_var "CONFLICT_TGT_REMOVED" )
        CONFLICT_SRC_REMOVED_FILE=$( file_from_var "CONFLICT_SRC_REMOVED" )

        SYNC_FROM=$( escaped_rsync_source )
        CONFLICT_LOC1="${RUN_DIR}"
        CONFLICT_LOC2="${SYNC_FROM}"
        RSYNC_CONFLICT_FLAG=
        if [[ ${CONFIG[MIRROR_CONFLICT_ACTION]} == "delete" ]]; then
            CONFLICT_LOC1="${SYNC_FROM}"
            CONFLICT_LOC2="${RUN_DIR}"
            RSYNC_CONFLICT_FLAG="--del"
        fi
        if [[ -s $CONFLICT_SRC_REMOVED_FILE || -s $CONFLICT_TGT_REMOVED_FILE ]]; then
            log_entry "| Conflict files found - resolving per config setting: ${CONFIG[MIRROR_CONFLICT_ACTION]}"
            if [[ $MIRROR_FAILURE -eq 0 && -s $CONFLICT_SRC_REMOVED_FILE ]]; then
                RSYNC_COMMAND="${CONFIG[RSYNC_PATH]} ${RSYNC_FLAGS} ${RSYNC_CONFLICT_FLAG} --files-from=${CONFLICT_SRC_REMOVED_FILE} ${CONFLICT_LOC1}/ ${CONFLICT_LOC2}/"
                log_entry "| Running rsync: $RSYNC_COMMAND"
                RSYNC_COMMAND="$RSYNC_COMMAND >> ${LOG_FILE} 2>&1"
                eval $RSYNC_COMMAND
                RSYNC_EXIT=$?
                if [[ $RSYNC_EXIT -ne 0 ]]; then
                    log_entry "| Rsync command exited with code: $RSYNC_EXIT"
                    MIRROR_FAILURE=1
                fi
            fi
            if [[ $MIRROR_FAILURE -eq 0 && -s $CONFLICT_TGT_REMOVED_FILE ]]; then
                RSYNC_COMMAND="${CONFIG[RSYNC_PATH]} ${RSYNC_FLAGS} ${RSYNC_CONFLICT_FLAG} --files-from=${CONFLICT_TGT_REMOVED_FILE} ${CONFLICT_LOC2}/ ${CONFLICT_LOC1}/"
                log_entry "| Running rsync: $RSYNC_COMMAND"
                RSYNC_COMMAND="$RSYNC_COMMAND >> ${LOG_FILE} 2>&1"
                eval $RSYNC_COMMAND
                RSYNC_EXIT=$?
                if [[ $RSYNC_EXIT -ne 0 ]]; then
                    log_entry "| Rsync command exited with code: $RSYNC_EXIT"
                    MIRROR_FAILURE=1
                fi
            fi
        fi
        rm $CONFLICT_TGT_REMOVED_FILE
        rm $CONFLICT_SRC_REMOVED_FILE
        # Remove missing source files from target and new target files list
        if [[ $MIRROR_FAILURE -eq 0 && ! -z $SRC_FILES_REMOVED ]]; then
            SRC_FILES_REMOVED_FILE=$( file_from_var "SRC_FILES_REMOVED" )
            log_entry "| Removing files from target dir"
            RSYNC_COMMAND="${CONFIG[RSYNC_PATH]} ${RSYNC_FLAGS} --del --files-from=${SRC_FILES_REMOVED_FILE} ${SYNC_FROM}/ ${RUN_DIR}/"
            log_entry "| Running rsync: $RSYNC_COMMAND"
            RSYNC_COMMAND="$RSYNC_COMMAND >> ${LOG_FILE} 2>&1"
            eval $RSYNC_COMMAND
            RSYNC_EXIT=$?
            if [[ $RSYNC_EXIT -gt 0 && $RSYNC_EXIT -ne 24 ]]; then
                log_entry "| Rsync command exited with code: $RSYNC_EXIT"
                MIRROR_FAILURE=1
            fi
            rm $SRC_FILES_REMOVED_FILE

            # Strip removed files from TGT_LIST_NEW
            TGT_LIST_NEW=$( remove_lines_ending_with TGT_LIST_NEW SRC_FILES_REMOVED )
        fi

        # Remove missing target files from source and new source files list
        if [[ $MIRROR_FAILURE -eq 0 && ! -z $TGT_FILES_REMOVED ]]; then
            TGT_FILES_REMOVED_FILE=$( file_from_var "TGT_FILES_REMOVED" )
            log_entry "| Removing files from source dir"
            RSYNC_COMMAND="${CONFIG[RSYNC_PATH]} ${RSYNC_FLAGS} --del --files-from=${TGT_FILES_REMOVED_FILE} ${RUN_DIR}/ ${SYNC_FROM}/"
            log_entry "| Running rsync: $RSYNC_COMMAND"
            RSYNC_COMMAND="$RSYNC_COMMAND >> ${LOG_FILE} 2>&1"
            eval $RSYNC_COMMAND
            RSYNC_EXIT=$?
            if [[ $RSYNC_EXIT -gt 0 && $RSYNC_EXIT -ne 24 ]]; then
                log_entry "| Rsync command exited with code: $RSYNC_EXIT"
                MIRROR_FAILURE=1
            fi
            rm $TGT_FILES_REMOVED_FILE

            # Strip removed files from SRC_LIST_NEW
            SRC_LIST_NEW=$( remove_lines_ending_with SRC_LIST_NEW TGT_FILES_REMOVED )
        fi

        # Add flag to only update if file is more recent
        RSYNC_FLAGS="${RSYNC_FLAGS} -u"

        # Update target from source (no delete, already handled)
        if [[ $MIRROR_FAILURE -eq 0 ]]; then
            SRC_FILES_SYNC=$( echo "$SRC_LIST_NEW" | cut -d ' ' -f 3- )
            SRC_FILES_SYNC_FILE=$( file_from_var "SRC_FILES_SYNC" )
            log_entry "| Updating target from files newer on source"
            RSYNC_COMMAND="${CONFIG[RSYNC_PATH]} ${RSYNC_FLAGS} --files-from=${SRC_FILES_SYNC_FILE} ${SYNC_FROM}/ ${RUN_DIR}/"
            log_entry "| Running rsync: $RSYNC_COMMAND"
            RSYNC_COMMAND="$RSYNC_COMMAND >> ${LOG_FILE} 2>&1"
            eval $RSYNC_COMMAND
            RSYNC_EXIT=$?
            if [[ $RSYNC_EXIT -gt 0 && $RSYNC_EXIT -ne 24 ]]; then
                log_entry "| Rsync command exited with code: $RSYNC_EXIT"
                MIRROR_FAILURE=1
            fi
        fi

        # Update source from target (no delete, already handled)
        if [[ $MIRROR_FAILURE -eq 0 ]]; then
            TGT_FILES_SYNC=$( echo "$TGT_LIST_NEW" | cut -d ' ' -f 3- )
            TGT_FILES_SYNC_FILE=$( file_from_var "TGT_FILES_SYNC" )
            log_entry "| Updating source from files newer on target"
            RSYNC_COMMAND="${CONFIG[RSYNC_PATH]} ${RSYNC_FLAGS} --files-from=${TGT_FILES_SYNC_FILE} ${RUN_DIR}/ ${SYNC_FROM}/"
            log_entry "| Running rsync: $RSYNC_COMMAND"
            RSYNC_COMMAND="$RSYNC_COMMAND >> ${LOG_FILE} 2>&1"
            eval $RSYNC_COMMAND
            RSYNC_EXIT=$?
            if [[ $RSYNC_EXIT -gt 0 && $RSYNC_EXIT -ne 24 ]]; then
                log_entry "| Rsync command exited with code: $RSYNC_EXIT"
                MIRROR_FAILURE=1
            fi
        fi
    fi

    # Run post-rsync scripts
    if [[ $MIRROR_FAILURE -ne 0 ]]; then
        log_entry "| Mirror job failed due to previous errors"
        command_runscript FAILED_SCRIPT
        mailer_rsync_exit $RSYNC_EXIT
    else
        # Save mirror file state listings
        echo "$SRC_LIST_NEW" > $SRC_LIST_FULL
        touch -d "${NEW_STARTTIME}" $SRC_LIST_FULL
        echo "$TGT_LIST_NEW" > $TGT_LIST_FULL
        touch -d "${NEW_STARTTIME}" $TGT_LIST_FULL

        command_runscript SUCCESS_SCRIPT
    fi

    # Update timestamp of target dir to indicate backup time
    touch $RUN_DIR
}

#######################################
# RESET COMMAND
#######################################

###############################
## Reset a failed job back to a ready state
## Returns 0 on reset ready, 1 on reset canceled
reset_makeready() {
    if [[ -t 0 ]] && status_is_running; then
        read -p "The $CONF_NAME job is currently running. Do you want to kill it? [y/N] " -n 1
        echo
        if [[ $REPLY == "y" ]]; then
            reset_killjob
        else
            echo "Leaving job running."
            return 1
        fi
    fi
    reset_killjob
    return 0
}

###############################
## Attempt to kill the currently running job; does nothing if no job if running
## Ends script with exit code 1 if a job is still running after kill attempt
reset_killjob() {
    if status_is_running; then
        PID=$( cat $PID_FULL )
        echo "Killing $CONF_NAME backup job, pid ${PID}..."
        kill $PID
        sleep 3
        if status_is_running; then
            echo "Job is still alive; hiring better assassins..."
            kill -9 $PID
            sleep 2
        fi
        if status_is_running; then
            echo "ERROR: Could not kill job for $CONF_NAME"
            exit 1
        fi
    fi
}

###############################
## Attempt to remove the pid file; does nothing if no pid file exists
## Ends script with exit code 1 if pid file exists and could not be deleted
reset_rmpidfile() {
    if [[ -f $PID_FULL ]]; then
        rm $PID_FULL
        if [[ $? -ne 0 ]]; then
            echo "ERROR: Could not remove pid file $PID_FULL"
            exit 1
        fi
    fi
}

###############################
## Attempt to move the running directory back to the oldest rotational directory name
## Does nothing for sync jobs
## For rotations using DATE subdir names, the dir name may not be what it was previously
reset_mvrundir() {
    if [[ ${CONFIG[BACKUP_TYPE]} == "rotation" ]]; then
        rotate_get_dirs
        if [[ ! -d $RUN_DIR || ${#BACKUP_ROTATION_DIRS[@]} -lt 1 ]]; then
            return
        fi
        rotate_reset
    fi
}

###############################
## For interactive terminals, get confirmation before killing a runnning job
command_reset() {
    if status_is_ready; then
        echo "Job '$CONF_NAME' is ready and does not need to be reset."
        exit 0
    fi

    if ! reset_makeready; then
        return
    fi
    reset_rmpidfile
    reset_mvrundir

    if status_is_ready; then
        echo "Job '$CONF_NAME' has been reset successfully."
    else
        echo "Job reset for '$CONF_NAME' failed!"
        exit 1
    fi
}

#######################################
# LIST COMMAND
#######################################

###############################
## Run list report
command_list() {
    # On sync job, report and exit
    if [[ ${CONFIG[BACKUP_TYPE]} != "rotation" ]]; then
        echo "Job '${CONF_NAME}' is not a rotation job. Backup lists only exist for rotation jobs."
        return
    fi

    rotate_get_dirs

    # Number of backups
    BACKUP_COUNT=$( rotate_backup_count )
    echo "Backups:  $BACKUP_COUNT / ${CONFIG[MAX_ROTATIONS]}"
    if [[ $BACKUP_COUNT -gt 0 ]]; then
        echo "------------------------------------------------------------"
    fi

    # List current backups
    for SDIR in "${BACKUP_ROTATION_DIRS[@]}"; do
        SDIR_FULL=$( epath_join "${CONFIG[TARGET_DIR]}" "$SDIR" )
        SDIR_STATE=""
        if [[ $SDIR_FULL == $RUN_DIR ]]; then
            if status_is_running; then
                SDIR_STATE="running"
            elif status_is_dead; then
                SDIR_STATE="dead"
            elif status_is_failed; then
                SDIR_STATE="failed"
            fi
            SDIR_STATE="(${SDIR_STATE})"
        fi
        SDIR_MTIME=$( date +%Y-%m-%d\ %H:%M -r $SDIR_FULL )
        printf '%-44s' "${SDIR%[[:space:]]}  $SDIR_STATE"
        printf '%s' "$SDIR_MTIME"
        echo
    done
    # List past-rotation directories
    if [[ ${#BACKUP_ROTATION_XDIRS[@]} -gt 0 ]]; then
        printf '%s' "------------- Backups Past Rotation Max ("
        PAST_NUM="${#BACKUP_ROTATION_XDIRS[@]}) -"
        PAST_PAD="------------------"
        printf '%s' "$PAST_NUM"
        printf '%*.*s' 0 $(( 19 - ${#PAST_NUM} )) "$PAST_PAD"
        echo
    fi
    for SDIR in "${BACKUP_ROTATION_XDIRS[@]}"; do
        SDIR_FULL=$( epath_join "${CONFIG[TARGET_DIR]}" "$SDIR" )
        SDIR_MTIME=$( date +%Y-%m-%d\ %H:%M -r $SDIR_FULL )
        printf '%-44s' "${SDIR%[[:space:]]}"
        printf '%s' "$SDIR_MTIME"
        echo
    done
}

#######################################
# HELP, GLOBALS, AND COMMAND SELECT
#######################################

# Command help
runhelp() {
    echo ""
    echo "Usage: cfgbackup [config-file] [command]"
    echo ""
    echo "    Creates backups of a directory given a config file specifying"
    echo "how the backup should be run. Each backup job uses a separate config"
    echo "file. See provided example.conf file as a template to use for"
    echo "setting up a config file. Scheduling of backups should be handled"
    echo "by cron."
    echo ""
    echo "COMMANDS:"
    echo "  check   - Perform a verification of the config file and check"
    echo "            that access to the source and target directories exist."
    echo "  status  - Print out the current status of any current job for the"
    echo "            given config. If no job is running, reports on the last"
    echo "            job that ran."
    echo "  list    - List rotational backup subdirectories for the given conf."
    echo "  run     - Run the backup according to the config file provided."
    echo "  reset   - Resets partially completed or failed backups. This will"
    echo "            abort a currently running backup."
    echo ""
    echo "cfgbackup v${VERSION}"
    echo ""
}

if [[ -z "$1" || $1 == "-h" || $1 == "--help" || $1 == "help" || $1 == "-V" || $1 == "--version" ]]; then
    runhelp
    exit 0
fi

# Grab command arguments
CONFIG_FILE=$1
COMMAND=$2

###############################
## Declare global variables
globals_init() {
    declare -g CONF_FILE_BASE
    declare -g CONF_NAME
    declare -g PID_FILE
    declare -g RUN_DIR
    declare -g PID_FULL
    CONF_FILE_BASE=$( basename $CONFIG_FILE )
    CONF_NAME=${CONF_FILE_BASE%.*}
    PID_FILE=$( printf '%q' "${CONFIG[PID_FILE]}" )
    # Globals for rotation job
    RUN_DIR=$( epath_join "${CONFIG[TARGET_DIR]}" "${CONFIG[RUNNING_DIRNAME]}" )
    PID_FULL=$( epath_join "${CONFIG[TARGET_DIR]}" "$PID_FILE" )
    # Globals for sync job
    if [[ ${CONFIG[BACKUP_TYPE]} == "sync" || ${CONFIG[BACKUP_TYPE]} == "mirror" ]]; then
        RUN_DIR=$( epath_join "${CONFIG[TARGET_DIR]}" )
        PID_FULL=$( path_join "$RUN_DIR" "$PID_FILE" )
    fi
}

###############################
## Validate the command given and select the appropriate action to perform
select_command() {
    # Validate command
    VALID_COMMANDS=(check status list run reset)
    array_contains VALID_COMMANDS $COMMAND
    if [[ $? != 0 ]]; then
        runhelp
        echo "ERROR: Invalid command given: $COMMAND"
        exit 1
    fi

    # Run commands
    if [[ $COMMAND == "check" ]]; then
        command_check
        echo "Config is OK."
    fi
    if [[ $COMMAND == "run" ]]; then
        command_check
        log_compress
        command_run
    fi
    if [[ $COMMAND == "status" ]]; then
        command_check
        command_status
    fi
    if [[ $COMMAND == "list" ]]; then
        command_list
    fi
    if [[ $COMMAND == "reset" ]]; then
        command_reset
    fi
}

###############################
## cfgbackup starts here
parse_config
precheck_requirements
globals_init
log_init
select_command

